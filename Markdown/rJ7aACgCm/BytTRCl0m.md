# Overview
## Hardware
The project hardware class consist of one central processing unit and 2048 MB of memory, as well as 1024MB of virtual memory. The simulator runs in steps defined as “looped” cycles.

These requirements are defined in the following object:

```kotlin
object Hardware {
    // Simulator cycle control
    var infCycle = false
    var intCycle = 0

    // CPU clock control
    var clockCycle = 0
        private set

    // Memory control
    private val availableMemory = 2048
    var usedMemory = 0
        private set

    fun tickCycle() {
        clockCycle++
    }

    fun getAvailableMemory(): Int {
        return availableMemory - usedMemory
    }

    fun borrowMemory(value: Int) {
        usedMemory += value
    }

    fun relieveMemory(value: Int) {
        usedMemory -= value
    }
}
```

Other classes and objects can access these values and use them as virtual hardware.
---
## I/O Operations
The simulator shall have I/O operations taking between 25 and 50 cycles. 

Event or I/O burst are created in below object:
```kotlin
import java.util.concurrent.ThreadLocalRandom

object EventHandler {
    private fun burst(): Int {
        return Hardware.clockCycle + ThreadLocalRandom.current().nextInt(25, 50 + 1)
    }

    fun scheduleIO(program: Program) {
        val interrupt = Interrupt(program, burst())
        InterruptHandler.addInterruptQueue(interrupt)
    }
}
```

# Job and Program Files

For job and program files, look at Basic Operations.

## Critical Sections
Each program must contain at least one critical section and at least a single critical section resolving scheme must be implemented. Additionally, for grade B and higher it is required for a at least single interprocess communication scheme must be implemented. Single level child-parent relationship must be used by processes. Additionally for grade A both a message passing scheme must be implemented. Multi-level child-parent relationship must be used by processes.

# Basic Operations
Four basic operations are required in this project program. 
1. Calculation (processing)
1. I/O simulation
1. Yielding (interrupts)
1. Output
Once loaded, the first line in a program file will input the process’ memory requirement (possibly an INT value). The following lines will be the “script” of operations: CALCULATE, I/O, YIELD, and OUT:

- CALCULATE – When this is read in, the simulator will run the process in the run state for the number of cycles specified as a parameter
- I/O – The simulator reads in this command, but a random number generator creates the parameter value in the main code or simulator (likely an INT value). This will put the process in the blocked state.
- YIELD – This command yields from or pauses the running process, halts its accumulating cycle time and gives priority to another process (possibly through the use of round-robin scheduling). These can act as random interrupts in the system.
- OUT – This will print out a message to the screen, possibly to indicate which process is running and all of its PCB information. This is similar to the user entered PROC command, but is generated by the system.
```kotlin
    fun execute() {
        if (currentProgram!!.runTime == 0) {
            val argument = currentProgram!!.argumentQueue.removeAt(0)
            val splitArgument = argument.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()

            when {
                argument.contains("CALCULATE") -> {
                    currentProgram!!.runTime = (Integer.valueOf(splitArgument[1]))
                    currentProgram!!.advanceRunTime()
                }
                argument.contains("IO") -> {
                    this.setProgramState(State.BLOCKED)
                    EventHandler.scheduleIO(currentProgram!!)
                    InterruptHandler.sendSignal(true)
                }
                argument.contains("YIELD") -> {
                    this.setProgramState(State.READY)
                    InterruptHandler.sendSignal(true)
                }
                argument.contains("OUT") -> {
                    val pid = currentProgram!!.pid
                    println(Formatter.ANSI_YELLOW + "OUT REQUEST FROM PID: " + pid + Formatter.ANSI_RESET)
                    CLI.proc(pid)
                }
            }
        } else {
            currentProgram!!.advanceRunTime()
        }
    }
```
Each operations are handled by the following execute function.
---
## Jobfile Creation Script
Job files will contain the random sequence of these operations or program instructions to simulate activity of a program.

“Job files” are text files that open and load the mock programs found in “program files”. The lines in a job file will be LOAD commands specifying the exact cycle time a process (in the program files) is to be loaded and put into the NEW queue or state. Also, the job file contains the string name of the process so it can be identified to the user. The EXE command is the last line in each job file script and will cause the simulator to load all other lines and information, storing it into the proper fields of the PCB.
```python
# TODO: Fix this to be more random
from random import randint

number = input("Enter amount of programs you want to create: ")
programs = []
i = 0
n = 0

while i < int(number):
    path = "program{}.txt".format(i)
    name = "program{}".format(i)
    programs.append(name)
    file = open(path, "w+")
    file.write("{}\n".format(str(randint(50, 800))))
    file.write("CALCULATE {}\n".format(str(randint(100, 500))))
    file.write("IO\n")
    file.write("CALCULATE {}\n".format(str(randint(50, 200))))
    file.write("YIELD\n")
    file.write("OUT\n")
    file.write("CALCULATE {}\n".format(str(randint(100, 1000))))
    file.close()
    i += 1

with open('job.txt', 'w') as filehandle:
    for listitem in programs:
        filehandle.write("LOAD {}\n".format(listitem))
    filehandle.write("EXE") 
```
---
## Cycles
The number of cycles represents a “run-time” or the length of all the instructions and math operations to be simulated for that particular program.

Below hardware object contains intCycle which represents length of runtime.
```kotlin
object Hardware {
    // Simulator cycle control
    var infCycle = false
    var intCycle = 0

    // CPU clock control
    var clockCycle = 0
        private set

    // Memory control
    private val availableMemory = 2048
    var usedMemory = 0
        private set

    fun tickCycle() {
        clockCycle++
    }

    fun getAvailableMemory(): Int {
        return availableMemory - usedMemory
    }

    fun borrowMemory(value: Int) {
        usedMemory += value
    }

    fun relieveMemory(value: Int) {
        usedMemory -= value
    }
}
```

In class CLI, function argIn, there is a method to take in specific amount of runtime a user request:
```kotlin
else if (argument.contains("exe")) {
            val splitArgument = argument.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()

            if (splitArgument.size == 2) {
                Hardware.infCycle = false
                Hardware.intCycle = Integer.valueOf(splitArgument[1]) - 1
                oprt.run()
            } else if (splitArgument.size == 1) {
                Hardware.infCycle = true
                Hardware.intCycle = -1
                oprt.run()
            } else {
                println("Specify the execution cycle count: (ex: exe 20)")
            }
        }
```
# User Interface
This program/simulator will incorporate a user interface so that he/she can control the flow of the operating system and observe the “running” of it for testing purposes. It must be possible to automatically and manually load a program or job file into the simulator thus to conduct the allocation of the program’s PCB and memory space. The exe command will let the simulator run on its own. The user can also specify the number of cycles to run before pausing.

# GUI
The GUI will display real-time statistics, visualizations and data on all currently running processes. The PCB information of the jobs that are in memory and in the run state will be shown in some sort of GUI data table. This GUI table is always “refreshing” or updating as the simulator runs on its own or steps through the code.

# Features
A command line embedded within GUI is required, which prompts the user for input. The user will initiate the start of a program with a command line in the simulator. User will specify the number of cycles the program can run for testing & observational purposes. 

## CLI
```kotlin
    @JvmStatic
    fun main(args: Array<String>) {
        var input: String
        println("Enter exit to exit the program.")

        if(runManual) {
            do {
                val read = Scanner(System.`in`)
                print("Console: ")

                input = read.nextLine()
                CLI.argIn(input)
                mainLoop()
            } while (true)
        } else {
            val file = File("programs/job.txt")
            val input = Scanner(file)
            val list = ArrayList<String>()

            while (input.hasNextLine()) {
                list.add(input.nextLine())
            }

            do {
                CLI.argIn(list.removeAt(0))
                mainLoop()
            } while (!list.isEmpty())

            CLI.argIn("proc")
        }
    }
```

The CLI is implemented via main method. Number of cycles or permanent cycle can be adjusted through bool value "runManual".

# Basic Operations
Four basic operations are required in this project program. They are calculation (processing), I/O simulation, yielding (interrupts), and output. Job files will contain the random sequence of these operations or program instructions to simulate activity of a program.
Example program:
`153`
`YIELD`
`YIELD`
`CALCULATE 483`
`CALCULATE 250`
`YIELD`
`OUT`
`YIELD`
`OUT`
`CALCULATE 439`
`IO`
`CALCULATE 319`
`CALCULATE 445`
`IO`
`YIELD`
`IO`

Four basic operations are all handeled in execute methond in the Processor class.
```kotlin
    fun execute() {
        if (currentProgram!!.runTime == 0) {
            val argument = currentProgram!!.argumentQueue.removeAt(0)
            val splitArgument = argument.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()

            when {
                argument.contains("CALCULATE") -> {
                    currentProgram!!.runTime = (Integer.valueOf(splitArgument[1]))
                    currentProgram!!.advanceRunTime()
                }
                argument.contains("IO") -> {
                    IO.scheduleIO(currentProgram!!)
                    this.setProgramState(State.BLOCKED)
                    InterruptHandler.sendSignal(true)
                }
                argument.contains("YIELD") -> {
                    this.setProgramState(State.READY)
                    InterruptHandler.sendSignal(true)
                }
                argument.contains("OUT") -> {
                    val pid = currentProgram!!.pid
                    println(Formatter.ANSI_YELLOW + "OUT REQUEST FROM PID: " + pid + Formatter.ANSI_RESET)
                    CLI.proc(pid)
                }
            }
        } else {
            currentProgram!!.advanceRunTime()
        }
    }
```

Please read other parts of the report for detail.